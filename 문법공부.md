# 문법공부



## import 

3대장 util, lang, io

```java
import java.util.*;
import java.lang.*;
import java.io.*;
```







## 입력

버퍼

문자 입력 스트림

```java
    public static void main(String[] args) throws IOException  {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int a = Integer.parseInt(br.readLine());
        System.out.println("Enter String");
        String b = br.readLine();
        System.out.println(a + b);
        
        
        // 문자열을 토큰화 한다.
        // 라인 단위로 받아들이는 것을 스페이스 기준으로 분리한다. 
        //스페이스 뿐만 아니라 컴마 등도 적용 가능하다
        String s = br.readLine();
        StringTokenizer st = new StringTokenizer(s, " ");
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        v = Integer.parseInt(st.nextToken()); 
        
        // 하나 입력
        int number = Integer.parseInt(br.readLine());
        
        // 마무리 
        br.close();
    }
```



* throws IOException

예외가 발생하면 해당 클래스에서 벗어나게 되는 것

모든 특이사항을 던저버린다는 말 

입력 함수를 만들 때 사용한다. readLine()



* StringTokenizer 

문자열을 토큰화 한다는 의미

라인 단위로 받는 입력값을 설정한 구분자로 나누어준다.

구분자를 스페이스로 설정하면 스페이스를 기준으로 나눈다. 



* Integer.paresInt(String s) 

숫자형의 문자열을 인자 값으로 받으면 해당 값을 10진수의 integer 형으로 반환해준다.

Inteer.parseInt(String s, int radix)

radix는 진수를 뜻한다. 8진수 16진수 등등



Scanner 입력

\- 읽은 바이트를 **문자, 정수, 실수, 불린, 문자열 등 다양한 타입으로 변환하여 리턴**하는 클래스

\- **java.util.Scanner**

\- Scanner는 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽는다.

\- 공백 문자 : **' \t ',' \f ',' \r ',' ',' \n '**

\- 개발자가 원하는 타입 값으로 쉽게 읽을 수 있다.

\- 프로그램을 실행시키고 콘솔창에 문자열을 입력하고 'Enter'를 누르면 된다



```java
import java.util.Scanner;

// Scanner 객체 생성
Scanner scan = new Scanner(System.in); 

// Scanner 주요 메소드

// 문자열
name = scan.next(); 

// byte
scan.nextByte();

// short
scan.nextShort();

// int
scan.nextInt();

// long
scan.nextLong();

// float 
scan.nextFloat();

// double
scan.nextDouble();

// '\n'을 포함한 한 라인을 읽고 '\n'을 버린 나머지만 리턴
scan.nextLine();

// 사용종료
void close();

// ㅇ
scan.hasNext();
```





## 출력



* 배열 한 번에 출력

Arrays를 이용하는 방법

```java
// 배열을 초기화 한다.
Arrays.fill(visited, 0);
System.out.println(Arrays.toString(visited));
```



```java
// 한 번에 두개의 변수 출력 n,m
System.out.printf("%d %d", n,m);
// printf와 제어 문자열 %을 쓰는 것이 포인트다 
```





## Queue 클래스

FIFO 형식 First In First Out

Enqueue : 큐 맨 뒤에 데이터 추가

Dequeue : 큐 맨 앞쪽의 데이터 삭제



``` java
import java.util.Linkedlist;
import java.util.Queue;

// 큐 선언 
// int형 queue 선언, linkedlist 이용
Queue<Integer> queue = new LinkedList<>();

// String형 queue 선언, linkedlist 이용
Queue<String> queue = new LinkedList<>();


// 값 추가
queue.add(1);
queue.offer(3);

// 값 삭제

// 첫번째 값을 뽑는다.
queue.poll();

// 첫번째 값 제거
queue.remove();

// 초기화
queue.clear();

// 출력
System.out.println("첫 번째 값 출력 : " + que.peek());

/* Iterator 클래스를 사용하여 값 출력 */ 
Iterator iter = que.iterator(); 
while(iter.hasNext()) 
    System.out.print(iter.next() + " ");


```





## static

Java에서 Static 변수는 메모리에 할당되어 프로그램이 종료될 때 해체되는 변수이다.

메모리에 한 번 할당되므로 여러 객체가 해당 메모리를 공유하게 된다.

Garbage Collector의 관리 영역 밖에 존재한다.

Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스의 악영향을 준다.



static을 앞으로 쓴다. 

static int



## 변수 선언

```java

static int n;
static int graph[][];
static int visited[];

// 크기 부여. 변수명[]
graph = new int[n+1][n+1];
visited = new int[n+1];

// 4방향
static int[] dx = {1,0,-1,0};
static int[] dy = {0,-1,0,1};

```





## 배열



```java
int[][] commands;
int[] array;

// 초기화
Arrays.fill(commands);

// 길이
commands.length;

// 정렬
Arrays.sort(commands);

// 출력
System.out.println(Arrays.toString(commands));

// 합계 
int[] hubo;
int result = Arrays.stream(hubo).sum();

// 값이 있는지 확인 
Arrays.asList(array).contains(value);



```



## 반복문

```java

// 배열 하나씩 꺼내기 
for(String part : participant) {
    
}


```





## Map



출저 : https://codechacha.com/ko/java-map-hashmap/



HashMap은 Map의 일종으로 key와 value의 쌍으로 이루어진 데이터를 보관한다. 

Map 은 인터페이스, HashMap 클래스 구현체 

```java

// 선언
HashMap<String, String> map1 = new HashMap<String, String>();
HashMap<String, Integer> hm = new HashMap<>();

// put()
// key, value로 저장
// null도 저장할 수 있다.
hm.put("apple", 1);
hm.put(null,4);

// putAll()
// 인자로 전달된 Map에 대한 데이터를 모두 저장
// putAll로 두 개의 Map을 합치는 예제
Map<String, Integer> fruits = new HashMap<>();
fruits.put("apple", 1);
fruits.put("banana", 2);
fruits.put("kiwi", 3);

Map<String, Integer> food = new HashMap<>();
food.put("coffee", 1);
food.put("hamburger", 2);
food.put("sandwich", 3);

food.putAll(fruits);
System.out.println("food: " + food);

// get()
// 인자로 전달된 key에 해당하는 value를 리턴해 준다.
// key가 없으면 null을 리턴한다.
fruits.put("apple", 1);
fruits.get("apple");

// remove()
// 인자로 전달된 key에 해당하는 데이터 삭제
// 삭제되면 value 값이 리턴된다.
fruits.put("apple", 1);
fruits.remove("apple");

// clear(), isEmpty()
// clear는 HashMap의 모든 데이터 삭제
// isEmpty는 HashMap의 데이터가 비었으면 true 아니면 false를 리턴
fruits.clear();
fruits.isEmpty();

// keySet(), values()
// keySet()은 HashMap에 저장된 key들을 Set 객체로 리턴
// values()는 HashMap에 저장된 value들을 Collection객체로 리턴
Set<String> keys = fruits.keySet();
Collection<Integer> values = fruits.values();

// containsKey(), containsValue()
// containsKey()는 인자로 전달된 key가 HashMap에 있으면 true를 리턴, 그렇지 않으면 false
// containsValue()는 인자로 전달된 value가 HashMap에 있으면 true를 리턴, 그렇지 않으면 false
fruits.containsKey("apple");
fruits.containsValue(1);

// replace()
// replace()는 인자로 전달된 key의 value를 인자로 전달된 value값으로 교체해준다.
fruits.put("apple", 1);
fruits.replace("apple", 10);

// getOrDefault(Object key, V DefaultValue)
// key : 값을 가저와야 하는 요소의 키
// defaultValue : 지정된 키로 매핑된 값이 없는 경우 반환되어야 하는 기본값 
// 찾는 key가 존재하면 key에 매핑된 값을 반환하고, 그렇지 않으면 디폴트 값을 반환한다.





map 탐색

​```java
for(String key : hm.keySet()) {
    
    
}
```





## 문자열(String)



문자열의 문자에 접근하기

```java
// 1. charAt() 메소드 활용
String str = "Hello world";
char c1 = str.charAt(0); 
// H 

// 2. String 클래스를 문자열 배열로 변환
char c2 = str.toCharArray()[2];
// l

// 문자열 길이 
str.length();

// 문자열 안 요소 확인
// true, false로 반환 
str.contains("H");

// 문자열 나누기
// str = 을 해야 처리한 결과가 더해진다.
str = str.substring(1, str.length() - 1);

// 문자열 붙이기
str += 'a';



```





## 이중배열 입력

```java
// 띄워쓰기 없이 붙여져 있는 입력값 

// 변수 선언
static int[][] board;

// 변수 크기 지정
board = new int[n][m];

// 스트링으로 입력 받은 다음 배열 채우기
for(int i = 0; i < n; i++){
    String str = br.readline();
    for(int j = 0; j < m; j++){
        board[i][j] = str.charAt(j) - '0';
    }
}

// 이중배열 출력
for(int i = 0; i < n; i++){
    System.out.println(Arrays.toString(board[i]));
}


```





## 리스트(List)



리스트는 자바의 자료형으로 배열보다 편리한 기능을 많이 가지고 있다.



배열은 크기가 정해진 것에 비해 리스트는 정해저 있지 않다.

동적으로 자료형의 갯수가 가변하는 상황에는 리스트를 사용하는 것이 유리하다.



>List 자료형에는 ArrayList, LinkedList 등의 List 인터페이스를 구현한 자료형이 있다.



```java
ArrayList<String> pitches = new ArrayList<String>();

// add() 추가
pitches.add("138");
pitches.add("129");

// 만약 2번째 위치에 삽입하고 싶을 경우
pitches.add(1, "133");


// get() 조회
// 2번째 값을 알고 싶을 때
pitches.get(1);

// size() 갯수를 조회
pitches.size();

// contains("값") 탐색 
// 값이 있으면 true 없으면 false(아마도?)
pitches.contains("138");


// remove() 제거 
// 2가지 방식이 있다. 객체, 인덱스
// remove(객체)
// remove(인덱스)

// remove(객체) 인 경우 해당되는 항목을 삭제하고 삭제한 결과를 리턴한다. 
pitches.remove("138");
// 수행 결과 true 

// remove(인덱스) 인 경우 항목을 삭제하고 값을 리턴한다.
pitches.remove(0);
// 수행 결과 138


// 이중 리스트
// ArrayList Integer 이용 
ArrayList<Integer[]> list = new ArrayList<Integer[]>();

list.add(new Integer[]{1,2,3});
list.add(new Integer[]{4,5,6});

list.get(0)[0]; 

// ArrayList List 중첩
List<List<Integer>> arr = new ArrayList<>();

for(int i = 0; i < n; i++){
    String[] arrRowTempItems = ();
    List<Integer> arrRowItems = new ArrayList<>();
    
    for(int j = 0; j < n; j++){
        int arrItem = Integer.parseInt(arrRowTempItems[j]);
        arrRowItems.add(arrItem);
    }
    arr.add(arrRowItems);
}

arr.get(1);
arr.get(1).get(0);



```







출저 : https://wikidocs.net/207



## 수학함수

```java
// max 함수
import java.util.Arrays;
int answer = Math.max(result, answer);
```





## 형변환

```java
// 문자 -> 숫자
// String -> Int
// Integer 클래스의 parseInt, valueOf 함수
String snum = "10";
int inum = Integer.parseInt(snum);
int inum2 = Integer.valueOIf(snum);


// String -> Double, Float
String snum = "10";
double dnum = Double.valueOf(snum);
float fnum = Float.valueOf(snum);


// String -> Long, Short
String snum = "10";
long inum = Long.parseLong(snum);
short shnum = Short.parseShort(snum);


// 숫자 -> 문자
// Int -> String
int inum = 10;
String snum;

snum = String.valueOf(inum);
snum = Integer.toString(inum);
snum = "" + inum;


// Double, Float -> String
float fnum = 10.10;
double dnum = 10.10;

String snum;

snum = String.valueOf(fnum);
snum = Float.toString(fnum);

snum = String.valueOf(dnum);
snum = Double.toString(dnum);


// 정수 <- -> 실수
// Double, Float -> Int
double dnum = 10.10;
float fnum = 10.10;

int inum;
inum = (int)dnum;
inum = (int)fnum;

// Int -> Dobule, Float
int inum = 10;

double dnum = (double)inum;
float fnum = (float)inum;

// 문자열 문자
String s = "String";

char c = s.charAt(6);
char[] ca = s.toCharArray();


// 아스키코드 변환
// 문자 -> 숫자
int num = (int)ch;

// 숫자 -> 문자 
char ch = (char)num;




```





## 우선순위큐 Priority Queue

출저 : https://coding-factory.tistory.com/603

큐는 데이터를 일시적으로 쌓아두기 위한 자료구조로 스택과 다르게 FIFO(Fist in First Out)의 구조이다

먼저 들어온 데이터가 먼저 나간다.

Priority Queue는 기존의 큐와 달리 우선순위를 먼저 결정하고 우선순위가 높은 요소가 먼저 나가는 자료구조이다.

우선순위 큐는 힙을 이용해 만드는 것이 일방적이다.



특징

1. 높은 우선순위의 요소를 먼저 꺼내서 처리하는 구조
2. 내부 요소는 힙으로 구성되어 이진트리 구조이다.
3. 내부구조가 힙으로 구성되었기에 시간 복잡도는 O(NLogN)
4. 응급실 같이 우선순위를 중요시해야 하는 상황에 쓰임



Priority Queue 사용법

```java
// 선언
import java.util.PriorityQueue;

// int형 priorityQueue (우선순위가 낮은 숫자 순)
PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();

// int형 priorityQueue (우선순위가 높은 숫자)
PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(Collections.reverseOrder());

// string형 priorityQueue (우선순위가 낮은 숫자)
PriorityQueue<String> priorityQueue = new PriorityQueue<>();

// string형 priorityQueue (우선순위가 높은 숫자)
PriorityQueue<String> priorityQueue = new PriorityQueue<>(Collections.reverseOrder());


// 값 추가
priorityQueue.add(1);
priorityQueue.add(2);

priorityQueue.offer(1);
priorityQueue.offer(2);


// 값 삭제

// 첫번째 값을 반환하고 제거, 비어있다면 null 반환
priorityQueue.poll();

// 첫번째값 제거
priorityQueue.remove();

// 초기화
priorityQueue.clear();


// 우선순위가 높은 값 출력
priorityQueue.peek();



// 우선순위의 크기
priorityQueue.size();









```







# 알고리즘 개념 공부



## 





# 워프









