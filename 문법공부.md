# 문법공부



## import 

3대장 util, lang, io

```java
import java.util.*;
import java.lang.*;
import java.io.*;
```







## 입력

버퍼

문자 입력 스트림

```java
    public static void main(String[] args) throws IOException  {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int a = Integer.parseInt(br.readLine());
        System.out.println("Enter String");
        String b = br.readLine();
        System.out.println(a + b);
        
        
        // 문자열을 토큰화 한다.
        // 라인 단위로 받아들이는 것을 스페이스 기준으로 분리한다. 
        //스페이스 뿐만 아니라 컴마 등도 적용 가능하다
        String s = br.readLine();
        StringTokenizer st = new StringTokenizer(s, " ");
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        v = Integer.parseInt(st.nextToken()); 
        
    }
```



* throws IOException

예외가 발생하면 해당 클래스에서 벗어나게 되는 것

모든 특이사항을 던저버린다는 말 

입력 함수를 만들 때 사용한다. readLine()



* StringTokenizer 

문자열을 토큰화 한다는 의미

라인 단위로 받는 입력값을 설정한 구분자로 나누어준다.

구분자를 스페이스로 설정하면 스페이스를 기준으로 나눈다. 



* Integer.paresInt(String s) 

숫자형의 문자열을 인자 값으로 받으면 해당 값을 10진수의 integer 형으로 반환해준다.

Inteer.parseInt(String s, int radix)

radix는 진수를 뜻한다. 8진수 16진수 등등



## 출력



* 배열 한 번에 출력

Arrays를 이용하는 방법

```java
// 배열을 초기화 한다.
Arrays.fill(visited, 0);
System.out.println(Arrays.toString(visited));
```







## Queue 클래스

FIFO 형식 First In First Out

Enqueue : 큐 맨 뒤에 데이터 추가

Dequeue : 큐 맨 앞쪽의 데이터 삭제



``` java
import java.util.Linkedlist;
import java.util.Queue;

// 큐 선언 
// int형 queue 선언, linkedlist 이용
Queue<Integer> queue = new LinkedList<>();

// String형 queue 선언, linkedlist 이용
Queue<String> queue = new LinkedList<>();


// 값 추가
queue.add(1);
queue.offer(3);

// 값 삭제

// 첫번째 값을 뽑는다.
queue.poll();

// 첫번째 값 제거
queue.remove();

// 초기화
queue.clear();

// 출력
System.out.println("첫 번째 값 출력 : " + que.peek());

/* Iterator 클래스를 사용하여 값 출력 */ 
Iterator iter = que.iterator(); 
while(iter.hasNext()) 
    System.out.print(iter.next() + " ");


```





## static

Java에서 Static 변수는 메모리에 할당되어 프로그램이 종료될 때 해체되는 변수이다.

메모리에 한 번 할당되므로 여러 객체가 해당 메모리를 공유하게 된다.

Garbage Collector의 관리 영역 밖에 존재한다.

Static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스의 악영향을 준다.



static을 앞으로 쓴다. 

static int



## 변수 선언

```java

static int n;
static int graph[][];
static int visited[];

// 크기 부여. 변수명[]
graph = new int[n+1][n+1];
visited = new int[n+1];

// 4방향
static int[] dx = {1,0,-1,0};
static int[] dy = {0,-1,0,1};

```





## 배열



```java
int[][] commands;

// 초기화
Arrays.fill(commands);

// 길이
commands.length;

// 정렬
Arrays.sort(commands);

// 출력
System.out.println(Arrays.toString(commands));




```



## 반복문

```java

// 배열 하나씩 꺼내기 
for(String part : participant) {
    
}


```





## Map



출저 : https://codechacha.com/ko/java-map-hashmap/



HashMap은 Map의 일종으로 key와 value의 쌍으로 이루어진 데이터를 보관한다. 



```java

// 선언
HashMap<String, String> map1 = new HashMap<String, String>();
HashMap<String, Integer> hm = new HashMap<>();

// put()
// key, value로 저장
// null도 저장할 수 있다.
hm.put("apple", 1);
hm.put(null,4);

// putAll()
// 인자로 전달된 Map에 대한 데이터를 모두 저장
// putAll로 두 개의 Map을 합치는 예제
Map<String, Integer> fruits = new HashMap<>();
fruits.put("apple", 1);
fruits.put("banana", 2);
fruits.put("kiwi", 3);

Map<String, Integer> food = new HashMap<>();
food.put("coffee", 1);
food.put("hamburger", 2);
food.put("sandwich", 3);

food.putAll(fruits);
System.out.println("food: " + food);

// get()
// 인자로 전달된 key에 해당하는 value를 리턴해 준다.
// key가 없으면 null을 리턴한다.
fruits.put("apple", 1);
fruits.get("apple");

// remove()
// 인자로 전달된 key에 해당하는 데이터 삭제
// 삭제되면 value 값이 리턴된다.
fruits.put("apple", 1);
fruits.remove("apple");

// clear(), isEmpty()
// clear는 HashMap의 모든 데이터 삭제
// isEmpty는 HashMap의 데이터가 비었으면 true 아니면 false를 리턴
fruits.clear();
fruits.isEmpty();

// keySet(), values()
// keySet()은 HashMap에 저장된 key들을 Set 객체로 리턴
// values()는 HashMap에 저장된 value들을 Collection객체로 리턴
Set<String> keys = fruits.keySet();
Collection<Integer> values = fruits.values();

// containsKey(), containsValue()
// containsKey()는 인자로 전달된 key가 HashMap에 있으면 true를 리턴, 그렇지 않으면 false
// containsValue()는 인자로 전달된 value가 HashMap에 있으면 true를 리턴, 그렇지 않으면 false
fruits.containsKey("apple");
fruits.containsValue(1);

// replace()
// replace()는 인자로 전달된 key의 value를 인자로 전달된 value값으로 교체해준다.
fruits.put("apple", 1);
fruits.replace("apple", 10);

// getOrDefault(Object key, V DefaultValue)
// key : 값을 가저와야 하는 요소의 키
// defaultValue : 지정된 키로 매핑된 값이 없는 경우 반환되어야 하는 기본값 
// 찾는 key가 존재하면 key에 매핑된 값을 반환하고, 그렇지 않으면 디폴트 값을 반환한다.





map 탐색

​```java
for(String key : hm.keySet()) {
    
    
}
```





## 문자열



문자열의 문자에 접근하기

```java
// 1. charAt() 메소드 활용
String str = "Hello world";
char c1 = str.charAt(0); 
// H 

// 2. String 클래스를 문자열 배열로 변환
char c2 = str.toCharArray()[2];
// l

```





## 이중배열 입력

```java
// 띄워쓰기 없이 붙여져 있는 입력값 

// 변수 선언
static int[][] board;

// 변수 크기 지정
board = new int[n][m];

// 스트링으로 입력 받은 다음 배열 채우기
for(int i = 0; i < n; i++){
    String str = br.readline();
    for(int j = 0; j < m; j++){
        board[i][j] = str.charAt(j) - '0';
    }
}

// 이중배열 출력
for(int i = 0; i < n; i++){
    System.out.println(Arrays.toString(board[i]));
}


```





























